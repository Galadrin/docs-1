(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{644:function(e,t,o){"use strict";o.r(t);var a=o(0),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"interpool-security"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#interpool-security"}},[e._v("#")]),e._v(" Interpool-security")]),e._v(" "),o("p",[e._v("Data can only be trustless if enough stake is behind it. To ensure the highest stake possible for an\nevergrowing amount of storage pools KYVE came up with the concept of "),o("code",[e._v("interpool-security")]),e._v(". Basically,\nthis allows validators to join multiple storage pools at once and therefore secure the pool with their\nentirety of stake.")]),e._v(" "),o("h2",{attrs:{id:"one-validator-multiple-pools"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#one-validator-multiple-pools"}},[e._v("#")]),e._v(" One validator - multiple pools")]),e._v(" "),o("p",[e._v('This has some huge benefits, the biggest of them is of course the higher stake\neach pool has now. So instead of splitting up the stake of a validator in each pool a pool is secured with\nthe entire stake, making the cost of attempting a 51% attack way higher. Futhermore, rewards can be massively\nincreased due to using the stake in "parallel". By validating in multiple pools a validator can earn double\nthe rewards if he runs on the twice the amount of pools as their competitors. But this of course comes also with a catch, running on multiple pools increases the risk of getting slashed in one of those pools. Getting slashed in one pool affects the entire stake, so the pools have to be chosen carefully.')]),e._v(" "),o("h2",{attrs:{id:"the-use-of-valaccounts"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#the-use-of-valaccounts"}},[e._v("#")]),e._v(" The use of Valaccounts")]),e._v(" "),o("p",[e._v("To make it possible for the Validator to participate on multiple pools without having to copy once's mnemonic to a\npotentially unsecure server where to protocol node should be hosted on KYVE uses "),o("code",[e._v("Valaccounts")]),e._v(" to run nodes. Basically,\nthe validator address can grant permissions to a random account to validate in the KYVE network on behalf of the staker.\nThis has to be done for every pool a validator wants to participate in. This ensures, that the validator does not have\nto export his private key to a server and enables massive horizontal scaling, due to the fact that validators and his valaccounts are decoupled from another. A potential setup with multiple pools can be found below:")]),e._v(" "),o("p",[o("img",{attrs:{src:"/interpool_security.png",alt:"interpool security"}})]),e._v(" "),o("p",[e._v("Here we can see that the validator granted permissions to three valaccount, were each of those runs on one pool. The node operator can decide if he wants to run multiple nodes on one machine like "),o("code",[e._v("Valaccount-1")]),e._v(" and "),o("code",[e._v("Valaccount-2")]),e._v(" or if he wants dedicated machines for every pool like "),o("code",[e._v("Valaccount-3")]),e._v(". Choosing the last option enables massive horizontal scaling and enables the validator to run on every pool KYVE will ever have.")])])}),[],!1,null,null,null);t.default=s.exports}}]);